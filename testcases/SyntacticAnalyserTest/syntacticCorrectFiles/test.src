// ====== Class declarations ====== //
struct POLYNOMIAL0 {
                                   //no member
};
struct POLYNOMIAL1 {
	private let a: float;
	private let b: float;          //no member function declaration
};

struct LINEAR inherits POLYNOMIAL {
	private let a: float;
	private let b: float;
	public  func build(A: float, B: float) -> LINEAR;
	public  func evaluate(x: float) -> float;
};

struct QUADRATIC inherits POLYNOMIAL0, POLYNOMIAL1 {  // multiple inherited class
	private let a: float;
	public let b: float;
	public let c: float;
	public  func build(A: float, B: float, C: float) -> QUADRATIC;
	public  func evaluate(x: float) -> float;
	public  func evaluate1(x: integer) -> integer;
};

// ====== struct implementations ====== //
impl POLYNOMIAL1 {
  func evaluate(x: float) -> float  //member function definition
  {
    return (0);
  }
  func evaluate1(x: integer) -> integer //multiple member function definitions
  {
     return (0);
  }
}

impl LINEAR {
  func build(A: float, B: float) -> LINEAR // return type id
  {
    let new_function: LINEAR;
    new_function.a = A;
    new_function.b = B;
    return (new_function);
  }
  func evaluate(x: float) -> float
  {
    let result: float;
    result = 0.0;
    result = a * x + b;
    return (result);
  }
}


/* sort the array */
func bubbleSort(arr: integer[], size: integer) -> void
{
  let n: integer;
  let i: integer;
  let j: integer;
  let temp: integer;
  n = size;
  i = 0;
  j = 0;
  temp = 0;
  while (i < n-1) {
    while (j < n-i-1) {
      if (arr[j] > arr[j+1])    // if statement
        then {
          // swap temp and arr[i]
          temp = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = temp;
        } else ;
        j = j+1;
      };
    i = i+1;
  };
}

/* print the array */
func printArray(arr: integer[], size: integer) -> void
{
  let n: integer;
  let i: integer;
  n = size;
  i = 0;
  while (i<n) {
    write(arr[i]);
      i = i+1;
  };
}

func printNumbers(arr: integer[10], ndim: integer[10][20]) -> void
// function formal parameters - array with size and n-dimensions
{
      let i: integer;
      i = 0;
      while (i<10) {
        write(arr[i]);
          i = i+1;
      };
}
func testFormalParametersTypeID(lin: LINEAR) -> void //testing the formal parameter with type id
{
    return(0);
}

func noParameters() -> void // function defintion with no parameter
{
    return(0); // function body one statement
}

func noLocalVariableDeclBlock() -> void //no local variable block
{
    //function body no statment
}

func testVariableIdnest() -> void
{
      x = a(b).c;                               //  id(id).id
      a(b).c();                                 //  id(id).id()
      a.b[c] = 0;                               //  id.id[id]
      a[b].c = 0;                               //  id[id].id
      a[b].c[d] = 0;                            //  id[id].id[id]
      a.b[c][d] = 0;                            //  d.id[id][id]
      a[b][c].d = 0;                            //  id[id][id].id
      a[b][c].d[e][f] = 0;                      //  id[id][id].id[id][id]
      x = a(b).c[d];                            //  id(id).id[id]
      x = a(b).c[d][e];                         //  id(id).id[id][id]
      a[m+n] = 0;                               //   expression as array index
}

// ====== main ====== //
func main() -> void
{
    let arr: integer[7];
    arr[0] = 64;
    arr[1] = 34;
    arr[2] = 25;
    arr[3] = 12;
    arr[4] = 22;
    arr[5] = 11;
    arr[6] = 90;

    let ndim: integer[1][7];
    ndim[0][1] = 64;
    ndim[0][2] = 34;
    ndim[0][3] = 25;
    ndim[0][4] = 12;
    ndim[0][5] = 22;
    ndim[0][6] = 11;
    ndim[0][7] = 90;
    printarray(arr, 7); // multiple free function definitions

    bubbleSort(arr, 7); // free function call

    noParameters(); //function call with no parameters

    printarray(arr, 7); // function call with array - 1dimension and no size

    printNumbers(arr , ndim); // function call with array -  2dimension

    printNumbers(arr , ndim[1][2]); // function call with array with size

    printarray(arr, 0+7); //function call with expression as parameter

    let i: integer; //variable type integer
    let f: float; //variable type float
    let arr1: integer[7]; //variable type array - 1D with size
    let arr1: integer[]; //variable type array - 1D without size
    let arr2: integer[7][7]; //variable type array - nDim

    let f1: LINEAR; // variable declaration ID
    let f2: QUADRATIC;
    let counter: integer;
    f1 = f1.build(2, 3.5);
    f2 = f2.build(-2.0, 1.0, 0.0);
    counter = 1;
    while(counter <= 10)    //using relop
      {
        write(counter);
        write(f1.evaluate(counter));
        write(f2.evaluate(counter)); //write
        read(a.b); // read
        return(a*b); // return
      };

    a = 2 + 3; //addop
    a = 2 * 3; //multop
    z = a*b+1;  //multop and addop
    while ((a*b+1) < 0)                        // involving addop + multop + relop
    {
    };
    while ((a*b) > 0)                        // involving multop + relop
    {
    };
    a = !0; // not operator
    return ((a)+(b)-(-c)*(!d) == 0);  // involving all the above in one expression
    a = 2 + (3*(3+5)); //nested parenthesis
    if( 3 > 4) // empty if else block
    then
    {
    }
    else{
    };
    if(3 >= 4)  // if: 1-statement then or else blocks
    then{
        a = 3;
    }
    else{
        b = 4;
    };

    if(3 <= 4)  // if: n-statement then or else blocks
        then{
            a = 3;
            b = 4;
        }
        else{
            b = 4;
            a = 3;
        };
    while (3 <> 4){ // empty while block
    };
}

/*
    classes
    --------------------------------------
| | no class declaration
|X| class declaration
|X| multiple class declarations
|X| no data member declaration
|X| data member declaration
|X| multiple data member declaration
|X| no member function declaration
|X| member function declaration
|X| multiple member function declaration
|X| no member
| | no inherited class
|X| one inherited class
|X| multiple inherited classes
|X| private member specifier
|X| public member specifier

    functions: definitions
    --------------------------------------
| | no main function definition
|X| main function definition
| | no free function definition
|X| free function definition
|X| multiple free function definitions
|X| no member function definition
|X| member function definition
|X| multiple member function definitions
|X| return type: void
|X| return type: integer
|X| return type: float
|X| return type: id
| | return type: array (not allowed)

    functions: formal parameters
    --------------------------------------
|X| type: integer
|X| type: float
|X| type: id
|X| type: 1-dim array
|X| type: n-dim array
|X| type: array (with size)
|X| type: array (without size)

    functions: calls
    --------------------------------------
|X| free function call
|X| member function call
|X| parameters:0
|X| parameters:1
|X| parameters:n
|X| array parameter - 1-dim
|X| array parameter - n-dim
|X| array parameter - with size
|X| array parameter - without size
|X| function call as statement
|X| function call as expression factor
|X| expression as parameter

    variable declaration
    --------------------------------------
|X| type: integer
|X| type: float
|| type: string
|X| type: id
|X| type: 1-dim array
|X| type: n-dim array
|X| type: array (with size)
| | type: array (without size) (not allowed)

    function body: local variable declarations
    --------------------------------------
|X| no local variable declarations
|X| local variable declarations
| | intertwined statements and variable declarations

    function body: statements
    --------------------------------------
|X| no statement
|X| 1 statement
|X| n statements
|X| if statement
|X| if: empty then or else blocks
|X| if: 1-statement then or else blocks
|X| if: n-statements then or else blocks
|X| while statement
|X| while: empty block
|X| while: 1-statement block
|X| while: n-statement block
|X| read(<variable>) statement
|X| write(<expr>) statement
|X| return(<expr>) statement
|X| assignment statement

    variable + idnest
    --------------------------------------
|X| id
|X| id.id
|X| id.id(id)
|X| id(id).id
|X| id(id).id()
|X| id.id[id]
|X| id[id].id
|X| id[id].id[id]
|X| id.id[id][id]
|X| id[id][id].id
|X| id[id][id].id[id][id]
|X| id(id).id[id]
|X| id(id).id[id][id]
|X| expression as array index

    expressions
    --------------------------------------
|X| single variable
|X| involving addop
|X| involving multop
|X| involving relop
|X| involving addop + multop
|X| involving multop + relop
|X| involving addop + multop + relop
|X| involving parentheses
|X| involving nested parentheses
|X| involving not
|X| involving sign
|| involving literals
|X| involving variable + idnest
|X| involving function calls
|X| involving all the above in one expression
*/