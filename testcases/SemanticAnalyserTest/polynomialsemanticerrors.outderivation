START
=> PROG
=> REPTPROG0
=> STRUCTORIMPLORFUNC REPTPROG0
=> STRUCTDECL REPTPROG0
=> struct id OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public FUNCDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public FUNCHEAD semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func id lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> TYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public FUNCDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public FUNCHEAD semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func id lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> TYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; STRUCTDECL REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct id OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public FUNCDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public FUNCHEAD semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func id lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> TYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public FUNCDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public FUNCHEAD semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func id lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> TYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; STRUCTDECL REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct id OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits id REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public FUNCDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public FUNCHEAD semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func id lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> TYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> id semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public FUNCDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public FUNCHEAD semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func id lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> TYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; STRUCTDECL REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct id OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits id REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public FUNCDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public FUNCHEAD semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func id lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> TYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> id semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public FUNCDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public FUNCHEAD semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func id lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate lpar FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( FPARAMS rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float rpar arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) arrow RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> RETURNTYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> TYPE semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; STRUCTDECL REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct id OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits id REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; STRUCTDECL REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct id OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits id REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; STRUCTDECL REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct id OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E OPTSTRUCTDECL2 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits id REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D REPTOPTSTRUCTDECL22 lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D lcurbr REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { VISIBILITY MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private MEMBERDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private VARDECL REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let id colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c colon TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : TYPE REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer REPTVARDECL4 semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer semi REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; REPTSTRUCTDECL4 rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; rcurbr semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } semi REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; IMPLDEF REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl id lcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL lcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { FUNCDEF REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { FUNCHEAD FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> TYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float lcurbr REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( ARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } IMPLDEF REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl id lcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR lcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { FUNCDEF REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { FUNCHEAD FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> TYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> id FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR lcurbr REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { VARDECL REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : id REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( ARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } FUNCDEF REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } FUNCHEAD FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> TYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float lcurbr REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { VARDECL REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = floatnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a MULTOP FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a mult FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x ADDOP TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x plus TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( ARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } IMPLDEF REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl id lcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC lcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { FUNCDEF REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { FUNCHEAD FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> TYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float lcurbr REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { VARDECL REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result MULTOP FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result mult FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x ADDOP TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x plus TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result MULTOP FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result mult FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x ADDOP TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x plus TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( ARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } FUNCDEF REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } FUNCHEAD FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> TYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> id FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC lcurbr REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { VARDECL REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : id REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ADDOP TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A plus TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B MULTOP FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B mult FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( ARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } FUNCDEF REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } FUNCHEAD FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float rpar arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) arrow RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> RETURNTYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> TYPE FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> id FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC FUNCBODY REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC lcurbr REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { VARDECL REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : id REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c assign EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = EXPR semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C EXPR1 semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; STATEMENT REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( EXPR rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( ARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function RIGHTRECARITHEXPR EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function EXPR1 rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function rpar semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) semi REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; REPTFUNCBODY1 rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; rcurbr REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } REPTIMPLDEF3 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } FUNCDEF REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } FUNCHEAD FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void lcurbr REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } FUNCDEF REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } FUNCHEAD FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void lcurbr REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } FUNCDEF REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } FUNCHEAD FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer FPARAMSTAIL REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer REPTFPARAMSTAIL4 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> TYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer lcurbr REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } FUNCDEF REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } FUNCHEAD FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer ARRAYSIZE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer lsqbr ARRAYSIZE1 REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ ARRAYSIZE1 REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ intnum rsqbr REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 rsqbr REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] ARRAYSIZE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] lsqbr ARRAYSIZE1 REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ ARRAYSIZE1 REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ intnum rsqbr REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 rsqbr REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> TYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer lcurbr REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } STRUCTORIMPLORFUNC REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } FUNCDEF REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } FUNCHEAD FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func id lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( rpar arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) arrow RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> RETURNTYPE FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void FUNCBODY REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void lcurbr REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { VARDECL REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : id REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; VARDECL REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : id REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; VARDECL REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : id REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; VARDECL REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : id REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; VARDECL REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; VARDECL REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; VARDECL REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer ARRAYSIZE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer lsqbr ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ intnum rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] ARRAYSIZE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] lsqbr ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ intnum rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; VARDECL REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let id colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j colon TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : TYPE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer ARRAYSIZE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer lsqbr ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ intnum rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] ARRAYSIZE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] lsqbr ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ intnum rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] ARRAYSIZE REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] lsqbr ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ ARRAYSIZE1 REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ intnum rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 rsqbr REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] REPTVARDECL4 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 dot id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build FUNCTIONCALLTAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build lpar APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( ARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 APARAMSTAIL REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 comma EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , ARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , floatnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 dot id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build FUNCTIONCALLTAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build lpar APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( ARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( SIGN FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( minus FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - floatnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 APARAMSTAIL REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 comma EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , ARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , floatnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 APARAMSTAIL REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 comma EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , ARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , floatnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c dot id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f FUNCTIONCALLTAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f lpar APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined FUNCTIONCALLTAIL STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined lpar APARAMS rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( APARAMS rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f FUNCTIONCALLTAIL STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f lpar APARAMS rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( APARAMS rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( ARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 APARAMSTAIL REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 comma EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , ARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 APARAMSTAIL REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 comma EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , ARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f FUNCTIONCALLTAIL STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f lpar APARAMS rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( APARAMS rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( ARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( floatnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 APARAMSTAIL REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 comma EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , ARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i INDICE VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i lsqbr ARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ ARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ TERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ intnum RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i INDICE VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i lsqbr ARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ ARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ TERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ intnum RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] INDICE VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] lsqbr ARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ ARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ TERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ floatnum RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 RIGHTRECARITHEXPR rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 rsqbr VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 FUNCTIONCALLTAIL STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 lpar APARAMS rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( APARAMS rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( EXPR REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( ARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j EXPR1 REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j REPTAPARAMS1 rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j rpar STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) STATEMENT3 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter dot id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . id STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x STATEMENT1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x VARIABLETAIL STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x STATEMENT2 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x assign EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = EXPR semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = ARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = TERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = intnum RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 RIGHTRECARITHEXPR EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 EXPR1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; VARDECLORSTAT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; STATEMENT REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while lpar EXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( EXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( ARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( TERM RIGHTRECARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter RIGHTRECARITHEXPR EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter EXPR1 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter RELOP ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter leq ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= TERM RIGHTRECARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= intnum RIGHTRECTERM RIGHTRECARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 RIGHTRECTERM RIGHTRECARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 RIGHTRECARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) STATBLOCK semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) lcurbr REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { STATEMENT REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( ARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; STATEMENT REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( ARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 dot id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate FUNCTIONCALLTAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate lpar APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( ARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; STATEMENT REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( ARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( TERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 dot id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate FUNCTIONCALLTAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate lpar APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( APARAMS rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( EXPR REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( ARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( TERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( id FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter FACTOR1 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter VARIABLETAIL FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter RIGHTRECARITHEXPR EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter EXPR1 REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter REPTAPARAMS1 rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter rpar FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) FACTOR2 RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) RIGHTRECTERM RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) RIGHTRECARITHEXPR EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) EXPR1 rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; rcurbr semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } semi REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } ; REPTFUNCBODY1 rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } ; rcurbr REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } ; } REPTPROG0
=> struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate2 ( x : float ) -> float ; } ; struct POLYNOMIAL { public func evaluate ( x : float ) -> float ; public func evaluate ( x : integer ) -> integer ; } ; struct LINEAR inherits POLYNOMIAL { private let a : float ; private let b : float ; private let b : integer ; public func build ( A : float , B : float ) -> LINEAR ; public func evaluate ( x : float ) -> float ; } ; struct QUADRATIC inherits LINEAR { private let a : float ; private let b : float ; private let c : float ; public func build ( A : float , B : float , C : float ) -> QUADRATIC ; public func evaluate ( x : float ) -> float ; } ; struct C inherits E { private let a : integer ; } ; struct D inherits C { private let b : integer ; } ; struct E inherits D { private let c : integer ; } ; impl POLYNOMIAL { func evaluate ( x : float ) -> float { return ( 0 ) ; } } impl LINEAR { func build ( A : float , B : float ) -> LINEAR { let new_function : LINEAR ; new_function . a = A ; new_function . b = B ; return ( new_function ) ; } func evaluate ( x : float ) -> float { let result : float ; result = 0.0 ; result = a * x + b ; return ( result ) ; } } impl QUADRATIC { func evaluate ( x : float ) -> float { let result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } func build ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A + B * 3 ; new_function . b = B ; new_function . c = 1 ; return ( 1 ) ; } func build2 ( A : float , B : float , C : float ) -> QUADRATIC { let new_function : QUADRATIC ; new_function . a = A ; new_function . b = B ; new_function . c = C ; return ( new_function ) ; } } func f ( i : integer ) -> void { } func f ( i : integer ) -> void { } func f ( i : integer , j : integer ) -> integer { } func f3 ( p1 : integer [ 2 ] [ 3 ] ) -> integer { } func main ( ) -> void { let a : a ; let c : C ; let f1 : LINEAR ; let f2 : QUADRATIC ; let counter : integer ; let counter : float ; let i : integer [ 2 ] [ 3 ] ; let j : integer [ 1 ] [ 2 ] [ 3 ] ; f1 = f1 . build ( 2 , 3.5 ) ; f2 = f2 . build ( - 2.0 , 1.0 , 0.0 ) ; c . b = 1 ; r = 5 ; counter = c . f ( ) ; undefined ( ) ; counter = r ; f ( 1 , 1 , 1 ) ; f ( 1.2 , 1 ) ; i [ 2 ] = 1 ; i [ 2 ] [ 1.3 ] = 2 ; f3 ( j ) ; counter . x = 1 ; while ( counter <= 10 ) { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write ( f2 . evaluate ( counter ) ) ; } ; } 
