package syntaxAnalyser;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Grammar {

    private ArrayList<String> terminal_list;
    private ArrayList<String> nonTerminal_list;
    private Map<String, String> symbol_map;
    private final Map<String, Rule> rules_attribute;

    private Map<String, ArrayList<String>> follow_sets;
    private Map<String, ArrayList<String>> first_sets;
    private Map<String, Map<String, String>> parsing_table;

    public Grammar() {
        nonTerminal_list = new ArrayList<>();
        rules_attribute = new HashMap<>();
        follow_sets = new HashMap<>();
        first_sets = new HashMap<>();
        parsing_table = new HashMap<>();
    }


    public void createSymbols() {

        symbol_map = Stream.of(new String[][]{{"dot", "."}, {"semi", ";"}, {"rpar", ")"}, {"lpar", "("},
                {"rcurbr", "}"}, {"lcurbr", "{"}, {"minus", "-"}, {"plus", "+"}, {"geq", ">="},
                {"leq", "<="}, {"gt", ">"}, {"lt", "<"}, {"neq", "<>"}, {"eq", "=="}, {"comma", ","},
                {"div", "/"}, {"mult", "*"}, {"rsqbr", "]"}, {"lsqbr", "["}, {"colon", ":"},
                {"not", "!"}, {"assign", "="}, {"or", "|"},{"and","&"},{"arrow","->"}
        }).collect(Collectors.toMap(data -> data[0], data -> data[1]));


        terminal_list = new ArrayList<>(Arrays.asList("$", "private", "public", "id", "dot", "semi", "struct", "float", "integer",
                "rpar", "lpar", "return", "write", "read", "while", "else", "then", "if", "rcurbr", "let","arrow",
                "lcurbr", "minus", "plus", "geq", "leq", "gt", "lt", "neq", "eq", "comma", "and", "div", "mult",
                "intnum", "inherits", "rsqbr", "lsqbr", "colon", "func", "void", "impl", "not", "floatnum", "assign", "or"));


        nonTerminal_list = new ArrayList<>(Arrays.asList(
                "START", "ADDOP", "APARAMS", "APARAMSTAIL", "ARITHEXPR", "ARRAYSIZE", "ARRAYSIZE1",
                "ASSIGNOP", "ASSIGNSTAT", "CLASSDECL", "EXPR1", "EXPR", "FACTOR1", "FACTOR2",
                "FACTOR", "FPARAMS", "FPARAMSTAIL", "FUNCBODY", "FUNCDECL", "FUNCDEF", "FUNCTIONCALL","FUNCTIONCALL1","FUNCTIONCALL2",
                "FUNCHEAD", "FUNCTIONCALLTAIL","IDNEST","IDNEST1","IMPLDEF", "INDICE",
                "MEMBERDECL", "MULTOP", "OPTSTRUCTDECL2", "PROG", "RELOP", "REPTAPARAMS1", "REPTFPARAMS3","REPTFPARAMS4",
                "SIGN", "RELEXPR","REPTFPARAMSTAIL4","REPTFUNCBODY1","REPTIDNEST1","REPTIMPLDEF3","REPTOPTSTRUCTDECL22",
                "REPTPROG0","REPTSTATBLOCK1","REPTSTRUCTDECL4","REPTVARDECL4","RETURNTYPE","RIGHTRECARITHEXPR","RIGHTRECTERM",
                "STATBLOCK", "STATEMENT", "STATEMENT1", "STATEMENT2","STATEMENT3","STRUCTDECL","STRUCTORIMPLORFUNC",
                "TERM","TYPE", "VARDECL", "VARIABLE2","VARIABLE3","VARDECLORSTAT", "VARIABLE", "VARIABLE1", "VARIABLETAIL", "VISIBILITY"));
    }


    public void generateGrammarProject() {
        createSymbols();
        importRules();
        createFirstSets();
        createFollowSets();
        createParsingTable();
    }

    private void createFirstSets() {
        first_sets.put("ADDOP", new ArrayList<>(Arrays.asList("plus", "minus", "or")));
        first_sets.put("ARRAYSIZE1", new ArrayList<>(Arrays.asList("intnum", "rsqbr")));
        first_sets.put("ASSIGNSTAT", new ArrayList<>(Collections.singletonList("id")));
        first_sets.put("EXPR1", new ArrayList<>(Arrays.asList("eq", "neq", "lt", "gt", "leq", "geq","EPSILON")));
        first_sets.put("FACTOR2", new ArrayList<>(Arrays.asList("dot", "EPSILON")));
        first_sets.put("FACTOR1",new ArrayList<>(Arrays.asList("dot","lpar","lsqbr", "EPSILON")));
        first_sets.put("FUNCBODY", new ArrayList<>(Collections.singletonList("lcurbr")));
        first_sets.put("FUNCHEAD", new ArrayList<>(Collections.singletonList("func")));
        first_sets.put("FPARAMS", new ArrayList<>(Arrays.asList("id", "EPSILON")));
        follow_sets.put("IDNEST", new ArrayList<>(Collections.singletonList("id")));
        first_sets.put("IDNEST1", new ArrayList<>(Arrays.asList("lpar", "lsqbr","EPSILON")));
        first_sets.put("APARAMS", new ArrayList<>(Arrays.asList("id", "intnum", "floatnum", "lpar", "not", "plus", "minus","EPSILON")));
        first_sets.put("FUNCDECL", new ArrayList<>(Collections.singletonList("func")));
        first_sets.put("ARITHEXPR", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        first_sets.put("RELOP", new ArrayList<>(Arrays.asList("eq", "neq", "lt", "gt", "leq", "geq")));
        first_sets.put("APARAMSTAIL", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTAPARAMS1", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTFPARAMS3", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("FPARAMSTAIL", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTFPARAMS4", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTFPARAMSTAIL4", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("REPTFUNCBODY1", new ArrayList<>(Arrays.asList("let", "id", "if", "while", "read", "write", "return","EPSILON")));
        first_sets.put("REPTIDNEST1", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("REPTOPTSTRUCTDECL22", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTIMPLDEF3", new ArrayList<>(Arrays.asList("func", "EPSILON")));
        first_sets.put("REPTPROG0", new ArrayList<>(Arrays.asList("struct", "impl", "func", "EPSILON")));
        first_sets.put("MEMBERDECL", new ArrayList<>(Arrays.asList("func", "let")));
        first_sets.put("ARRAYSIZE", new ArrayList<>(Collections.singletonList("lsqbr")));
        first_sets.put("RETURNTYPE", new ArrayList<>(Arrays.asList("void", "integer", "float", "id")));
        first_sets.put("RIGHTRECARITHEXPR", new ArrayList<>(Arrays.asList("plus", "minus", "or")));
        first_sets.put("SIGN", new ArrayList<>(Arrays.asList("plus", "minus")));
        first_sets.put("MULTOP", new ArrayList<>(Arrays.asList("mult", "div", "and")));
        first_sets.put("PROG", new ArrayList<>(Arrays.asList("struct", "impl", "func", "EPSILON")));
        first_sets.put("START", new ArrayList<>(Arrays.asList("struct", "impl", "func", "EPSILON")));
        first_sets.put("REPTSTATBLOCK1", new ArrayList<>(Arrays.asList("id", "if", "while", "read", "write", "return", "EPSILON")));
        first_sets.put("RELEXPR", new ArrayList<>(Arrays.asList("id", "intnum", "floatnum", "lpar", "not", "plus", "minus")));
        first_sets.put("STATBLOCK", new ArrayList<>(Arrays.asList("lcurbr", "if", "while", "read", "write", "return", 	"id", "EPSILON")));
        first_sets.put("STATEMENT2", new ArrayList<>(Arrays.asList("dot", "equal")));
        first_sets.put("ASSIGNOP", new ArrayList<>(Collections.singletonList("equal")));
        first_sets.put("EXPR", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        first_sets.put("STATEMENT3", new ArrayList<>(Arrays.asList("dot", "EPSILON")));
        first_sets.put("STATEMENT1", new ArrayList<>(Arrays.asList("dot", "lpar", "lsqbr", "equal")));
        first_sets.put("OPTSTRUCTDECL2", new ArrayList<>(Arrays.asList("inherits", "EPSILON")));
        first_sets.put("REPTSTRUCTDECL4", new ArrayList<>(Arrays.asList("public", "private", "EPSILON")));
        first_sets.put("STRUCTORIMPLORFUNC", new ArrayList<>(Arrays.asList("struct", "impl", "func")));
        first_sets.put("STRUCTDECL", new ArrayList<>(Collections.singletonList("struct")));
        first_sets.put("IMPLDEF", new ArrayList<>(Collections.singletonList("impl")));
        first_sets.put("FUNCDEF", new ArrayList<>(Collections.singletonList("func")));
        first_sets.put("TERM", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        first_sets.put("FACTOR", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        first_sets.put("RIGHTRECTERM", new ArrayList<>(Arrays.asList("mult", "div", "and","EPSILON")));
        first_sets.put("TYPE", new ArrayList<>(Arrays.asList("integer", "float", "id")));
        first_sets.put("REPTVARDECL4", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("VARDECLORSTAT", new ArrayList<>(Arrays.asList("let", "id", "if", "while", "read", "write", "return")));
        first_sets.put("VARDECL", new ArrayList<>(Collections.singletonList("let")));
        first_sets.put("STATEMENT", new ArrayList<>(Arrays.asList("if", "while", "read", "write", "return", "id")));
        first_sets.put("VARIABLE", new ArrayList<>(Collections.singletonList("id")));
        first_sets.put("FUNCTIONCALLTAIL", new ArrayList<>(Collections.singletonList("lpar")));
        first_sets.put("VARIABLE2", new ArrayList<>(Arrays.asList("dot", "EPSILON")));
        first_sets.put("VARIABLE3", new ArrayList<>(Collections.singletonList("dot")));
        first_sets.put("VARIABLE1", new ArrayList<>(Arrays.asList("dot","lpar","lsqbr", "EPSILON")));
        first_sets.put("INDICE", new ArrayList<>(Collections.singletonList("lsqbr")));
        first_sets.put("VARIABLETAIL", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("VISIBILITY", new ArrayList<>(Arrays.asList("public", "private")));
    }
    private void createFollowSets() {
        follow_sets.put("ADDOP", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("ARRAYSIZE1", new ArrayList<>(Arrays.asList("semi", "lsqbr", "rpar", "comma")));
        follow_sets.put("ASSIGNSTAT", new ArrayList<>(Collections.singletonList("âˆ…")));
        follow_sets.put("EXPR1", new ArrayList<>(Arrays.asList("semi", "comma", "rpar")));
        follow_sets.put("FACTOR2", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma", "rsqbr", "rpar")));
        follow_sets.put("FACTOR1", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma", "rsqbr", "rpar")));
        follow_sets.put("FUNCBODY", new ArrayList<>(Arrays.asList("struct", "impl", "rcurbr", "func")));
        follow_sets.put("FUNCHEAD", new ArrayList<>(Arrays.asList("semi","lcurbr")));
        follow_sets.put("FPARAMS", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("IDNEST", new ArrayList<>(Collections.singletonList("âˆ…")));
        follow_sets.put("IDNEST1", new ArrayList<>(Collections.singletonList("dot")));
        follow_sets.put("APARAMS", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("FUNCDECL", new ArrayList<>(Arrays.asList("public", "private", "rcurbr")));
        follow_sets.put("ARITHEXPR", new ArrayList<>(Arrays.asList("semi", "eq", "neq", "lt", "gt", "leq", "geq", "comma", "rsqbr", "rpar")));
        follow_sets.put("RELOP", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("APARAMSTAIL", new ArrayList<>(Arrays.asList("comma","rpar")));
        follow_sets.put("REPTAPARAMS1", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("REPTFPARAMS3", new ArrayList<>(Arrays.asList("comma","rpar")));
        follow_sets.put("FPARAMSTAIL", new ArrayList<>(Arrays.asList("comma","rpar")));
        follow_sets.put("REPTFPARAMS4", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("REPTFPARAMSTAIL4", new ArrayList<>(Arrays.asList("comma","rpar")));
        follow_sets.put("REPTFUNCBODY1", new ArrayList<>(Collections.singletonList("rcurbr")));
        follow_sets.put("REPTIDNEST1", new ArrayList<>(Collections.singletonList("dot")));
        follow_sets.put("REPTIMPLDEF3", new ArrayList<>(Collections.singletonList("rcurbr")));
        follow_sets.put("REPTOPTSTRUCTDECL2", new ArrayList<>(Collections.singletonList("lcurbr")));
        follow_sets.put("REPTPROG0", new ArrayList<>(Collections.singletonList("âˆ…")));
        follow_sets.put("MEMBERDECL", new ArrayList<>(Arrays.asList("public", "private", "rcurbr")));
        follow_sets.put("ARRAYSIZE", new ArrayList<>(Arrays.asList("rpar", "comma", "semi","lsqbr")));
        follow_sets.put("RETURNTYPE", new ArrayList<>(Arrays.asList("lcurbr", "semi")));
        follow_sets.put("RIGHTRECARITHEXPR", new ArrayList<>(Arrays.asList("semi", "eq", "neq", "lt", "gt", "leq", "geq", "comma", "rsqbr", "rpar")));
        follow_sets.put("MULTOP", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("SIGN", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("START", new ArrayList<>(Collections.singletonList("âˆ…")));
        follow_sets.put("PROG", new ArrayList<>(Collections.singletonList("âˆ…")));
        follow_sets.put("REPTSTATBLOCK1", new ArrayList<>(Collections.singletonList("rcurbr")));
        follow_sets.put("RELEXPR", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("STATBLOCK", new ArrayList<>(Arrays.asList("else", "semi")));
        follow_sets.put("STATEMENT2", new ArrayList<>(Collections.singletonList("semi")));
        follow_sets.put("ASSIGNOP", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("EXPR", new ArrayList<>(Arrays.asList("semi", "comma", "rpar")));
        follow_sets.put("STATEMENT3", new ArrayList<>(Collections.singletonList("semi")));
        follow_sets.put("STATEMENT1", new ArrayList<>(Collections.singletonList("semi")));
        follow_sets.put("OPTSTRUCTDECL2", new ArrayList<>(Collections.singletonList("lcurbr")));
        follow_sets.put("REPTSTRUCTDECL4", new ArrayList<>(Collections.singletonList("rcurbr")));
        follow_sets.put("STRUCTORIMPLORFUNC", new ArrayList<>(Arrays.asList("struct", "impl", "func")));
        follow_sets.put("STRUCTDECL", new ArrayList<>(Arrays.asList("struct", "impl", "func")));
        follow_sets.put("IMPLDEF", new ArrayList<>(Arrays.asList("struct", "impl", "func")));
        follow_sets.put("FUNCDEF", new ArrayList<>(Arrays.asList("struct", "impl", "func", "rcurbr")));
        follow_sets.put("TERM", new ArrayList<>(Arrays.asList("semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma", "rsqbr", "rpar")));
        follow_sets.put("FACTOR", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma",  "rsqbr", "rpar")));
        follow_sets.put("RIGHTRECTERM", new ArrayList<>(Arrays.asList("semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma", "rsqbr", "rpar")));
        follow_sets.put("TYPE", new ArrayList<>(Arrays.asList("lcurbr", "semi", "rpar", "comma", "lsqbr")));
        follow_sets.put("REPTVARDECL4", new ArrayList<>(Collections.singletonList("semi")));
        follow_sets.put("VARDECLORSTAT", new ArrayList<>(Arrays.asList("if", "while", "read", "write", "return", "let", "id", "rcurbr")));
        follow_sets.put("VARDECL", new ArrayList<>(Arrays.asList("public", "private", "let", "while", "read", "write", "return", "if", "id", "rcurbr")));
        follow_sets.put("STATEMENT", new ArrayList<>(Arrays.asList("if", "while", "read", "write", "return", "let", "id", "else", "semi", "rcurbr")));
        follow_sets.put("VARIABLE", new ArrayList<>(Arrays.asList("equal", "rpar")));
        follow_sets.put("FUNCTIONCALLTAIL", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma",  "rsqbr", "rpar","dot")));
        follow_sets.put("VARIABLE2", new ArrayList<>(Arrays.asList("equal", "rpar")));
        follow_sets.put("VARIABLE3", new ArrayList<>(Arrays.asList("equal", "rpar")));
        follow_sets.put("VARIABLE1", new ArrayList<>(Arrays.asList("equal", "rpar")));
        follow_sets.put("INDICE", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma",  "rsqbr", "rpar","dot","lsqbr","equal")));
        follow_sets.put("VARIABLETAIL", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma",  "rsqbr", "rpar", "dot", "equal")));
        follow_sets.put("VISIBILITY", new ArrayList<>(Arrays.asList("func", "let")));
    }


    private void createParsingTable() {

        Map<String, String> table_entry_table;
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "ADDOP_minus"}, {"plus", "ADDOP_plus"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "ADDOP_or"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ADDOP", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "APARAMS_EXPR_REPTAPARAMS1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "APARAMS_EPSILON"}, {"lpar", "APARAMS_EXPR_REPTAPARAMS1"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "APARAMS_EXPR_REPTAPARAMS1"}, {"plus", "APARAMS_EXPR_REPTAPARAMS1"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "APARAMS_EXPR_REPTAPARAMS1"}, {"floatlit", "APARAMS_EXPR_REPTAPARAMS1"}, {"intlit", "APARAMS_EXPR_REPTAPARAMS1"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("APARAMS", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "APARAMSTAIL_comma_EXPR"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("APARAMSTAIL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"plus", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"floatlit", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"intlit", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ARITHEXPR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "ARRAYSIZE_lsqbr_ARRAYSIZE1"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ARRAYSIZE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "ARRAYSIZE1_rsqbr"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "ARRAYSIZE1_intnum_rsqbr"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ARRAYSIZE1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "ASSIGNOP_equal"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ASSIGNOP", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "ASSIGNSTAT_VARIABLE_ASSIGNOP_EXPR"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ASSIGNSTAT", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "EXPR_ARITHEXPR_EXPR1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "EXPR_ARITHEXPR_EXPR1"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "EXPR_ARITHEXPR_EXPR1"}, {"plus", "EXPR_ARITHEXPR_EXPR1"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "EXPR_ARITHEXPR_EXPR1"}, {"floatlit", "EXPR_ARITHEXPR_EXPR1"}, {"intlit", "EXPR_ARITHEXPR_EXPR1"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("EXPR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "EXPR1_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "EXPR1_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "EXPR1_EPSILON"}, {"geq", "EXPR1_RELOP_ARITHEXPR"}, {"leq", "EXPR1_RELOP_ARITHEXPR"}, {"gt", "EXPR1_RELOP_ARITHEXPR"}, {"lt", "EXPR1_RELOP_ARITHEXPR"}, {"neq", "EXPR1_RELOP_ARITHEXPR"}, {"eq", "EXPR1_RELOP_ARITHEXPR"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("EXPR1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "FACTOR_id_FACTOR1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "FACTOR_lpar_ARITHEXPR_rpar"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "FACTOR_SIGN_FACTOR"}, {"plus", "FACTOR_SIGN_FACTOR"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "FACTOR_not_FACTOR"}, {"floatlit", "FACTOR_floatlit"}, {"intlit", "FACTOR_intlit"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FACTOR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"semi", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"lpar", "FACTOR1_FUNCTIONCALLTAIL_FACTOR2"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"plus", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"void", "error"}, {"comma", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"geq", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"leq", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"gt", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"lt", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"neq", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"eq", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"inherits", "error"}, {"and", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"div", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"mult", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"rsqbr", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"lsqbr", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "FACTOR1_VARIABLETAIL_FACTOR2"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FACTOR1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "FACTOR2_dot_id_FACTOR1"}, {"semi", "FACTOR2_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "FACTOR2_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "FACTOR2_EPSILON"}, {"plus", "FACTOR2_EPSILON"}, {"void", "error"}, {"comma", "FACTOR2_EPSILON"}, {"geq", "FACTOR2_EPSILON"}, {"leq", "FACTOR2_EPSILON"}, {"gt", "FACTOR2_EPSILON"}, {"lt", "FACTOR2_EPSILON"}, {"neq", "FACTOR2_EPSILON"}, {"eq", "FACTOR2_EPSILON"}, {"inherits", "error"}, {"and", "FACTOR2_EPSILON"}, {"div", "FACTOR2_EPSILON"}, {"mult", "FACTOR2_EPSILON"}, {"rsqbr", "FACTOR2_EPSILON"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "FACTOR2_EPSILON"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FACTOR2", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "FPARAMS_id_colon_TYPE_REPTFPARAMS3_REPTFPARAMS4"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "FPARAMS_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FPARAMS", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "FPARAMSTAIL_comma_id_colon_TYPE_REPTFPARAMSTAIL4"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FPARAMSTAIL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "FUNCBODY_lcurbr_REPTFUNCBODY1_rcurbr"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCBODY", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "FUNCDECL_FUNCHEAD_semi"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCDECL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "FUNCDEF_FUNCHEAD_FUNCBODY"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCDEF", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "FUNCHEAD_func_id_lpar_FPARAMS_rpar_arrow_RETURNTYPE"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCHEAD", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "FUNCTIONCALLTAIL_lpar_APARAMS_rpar"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCTIONCALLTAIL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "IDNEST_id_IDNEST1_dot"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("IDNEST", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "IDNEST1_REPTIDNEST1"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "IDNEST1_lpar_APARAMS_rpar"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "IDNEST1_REPTIDNEST1"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("IDNEST1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "IMPLDEF_impl_id_lcurbr_REPTIMPLDEF3_rcurbr"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("IMPLDEF", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "INDICE_lsqbr_ARITHEXPR_rsqbr"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("INDICE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "MEMBERDECL_VARDECL"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "MEMBERDECL_FUNCDECL"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("MEMBERDECL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "MULTOP_and"}, {"div", "MULTOP_div"}, {"mult", "MULTOP_mult"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("MULTOP", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "OPTSTRUCTDECL2_EPSILON"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "OPTSTRUCTDECL2_inherits_id_REPTOPTSTRUCTDECL22"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("OPTSTRUCTDECL2", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "PROG_REPTPROG0"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "PROG_REPTPROG0"}, {"arrow", "error"}, {"func", "PROG_REPTPROG0"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("PROG", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"plus", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"floatlit", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"intlit", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RELEXPR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "RELOP_geq"}, {"leq", "RELOP_leq"}, {"gt", "RELOP_gt"}, {"lt", "RELOP_lt"}, {"neq", "RELOP_neq"}, {"eq", "RELOP_eq"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RELOP", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "REPTAPARAMS1_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTAPARAMS1_APARAMSTAIL_REPTAPARAMS1"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTAPARAMS1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "REPTAPARAMS3_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTAPARAMS3_EPSILON"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "REPTFPARAMS3_ARRAYSIZE_REPTFPARAMS3"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTFPARAMS3", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "REPTAPARAMS4_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTFPARAMS4_FPARAMSTAIL_REPTFPARAMS4"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTFPARAMS4", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "REPTFPARAMSTAIL4_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTFPARAMSTAIL4_EPSILON"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "REPTFPARAMSTAIL4_ARRAYSIZE_REPTFPARAMSTAIL4"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTFPARAMSTAIL4", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "REPTFUNCBODY1_EPSILON"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"write", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"read", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"while", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"else", "error"}, {"then", "error"}, {"if", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTFUNCBODY1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "REPTIDNEST1_EPSILON"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "REPTIDNEST1_INDICE_REPTIDNEST1"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTIDNEST1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "REPTIMPLDEF3_EPSILON"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "REPTIMPLDEF3_FUNCDEF_REPTIMPLDEF3"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTIMPLDEF3", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "REPTOPTSTRUCTDECL22_EPSILON"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTOPTSTRUCTDECL22_comma_id_REPTOPTSTRUCTDECL22"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTOPTSTRUCTDECL22", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "REPTPROG0_STRUCTORIMPLORFUNC_REPTPROG0"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "REPTPROG0_STRUCTORIMPLORFUNC_REPTPROG0"}, {"arrow", "error"}, {"func", "REPTPROG0_STRUCTORIMPLORFUNC_REPTPROG0"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTPROG0", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "REPTSTATBLOCK1_EPSILON"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"write", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"read", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"while", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"else", "error"}, {"then", "error"}, {"if", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTSTATBLOCK1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "REPTSTRUCTDECL4_VISIBILITY_MEMBERDECL_REPTSTRUCTDECL4"}, {"public", "REPTSTRUCTDECL4_VISIBILITY_MEMBERDECL_REPTSTRUCTDECL4"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "REPTSTRUCTDECL4_EPSILON"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTSTRUCTDECL4", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "REPTVARDECL4_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "REPTVARDECL4_ARRAYSIZE_REPTVARDECL4"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTVARDECL4", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "RETURNTYPE_TYPE"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "RETURNTYPE_TYPE"}, {"integer", "RETURNTYPE_TYPE"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "RETURNTYPE_VOID"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RETURNTYPE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "RIGHTRECARITHEXPR_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "RIGHTRECARITHEXPR_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "RIGHTRECARITHEXPR_ADDOP_TERM_RIGHTRECARITHEXPR"}, {"plus", "RIGHTRECARITHEXPR_ADDOP_TERM_RIGHTRECARITHEXPR"}, {"void", "error"}, {"comma", "RIGHTRECARITHEXPR_EPSILON"}, {"geq", "RIGHTRECARITHEXPR_EPSILON"}, {"leq", "RIGHTRECARITHEXPR_EPSILON"}, {"gt", "RIGHTRECARITHEXPR_EPSILON"}, {"lt", "RIGHTRECARITHEXPR_EPSILON"}, {"neq", "RIGHTRECARITHEXPR_EPSILON"}, {"eq", "RIGHTRECARITHEXPR_EPSILON"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "RIGHTRECARITHEXPR_EPSILON"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "RIGHTRECARITHEXPR_ADDOP_TERM_RIGHTRECARITHEXPR"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RIGHTRECARITHEXPR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "RIGHTRECTERM_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "RIGHTRECTERM_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "RIGHTRECTERM_EPSILON"}, {"plus", "RIGHTRECTERM_EPSILON"}, {"void", "error"}, {"comma", "RIGHTRECTERM_EPSILON"}, {"geq", "RIGHTRECTERM_EPSILON"}, {"leq", "RIGHTRECTERM_EPSILON"}, {"gt", "RIGHTRECTERM_EPSILON"}, {"lt", "RIGHTRECTERM_EPSILON"}, {"neq", "RIGHTRECTERM_EPSILON"}, {"eq", "RIGHTRECTERM_EPSILON"}, {"inherits", "error"}, {"and", "RIGHTRECTERM_MULTOP_FACTOR_RIGHTRECTERM"}, {"div", "RIGHTRECTERM_MULTOP_FACTOR_RIGHTRECTERM"}, {"mult", "RIGHTRECTERM_MULTOP_FACTOR_RIGHTRECTERM"}, {"rsqbr", "RIGHTRECTERM_EPSILON"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "RIGHTRECTERM_EPSILON"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RIGHTRECTERM", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "SIGN_minus"}, {"plus", "SIGN_plus"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("SIGN", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "START_PROG"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "START_PROG"}, {"arrow", "error"}, {"func", "START_PROG"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("START", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "STATBLOCK_STATEMENT"}, {"dot", "error"}, {"semi", "STATBLOCK_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "STATBLOCK_lcurbr_REPTSTATBLOCK1_rcurbr"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "STATBLOCK_STATEMENT"}, {"write", "STATBLOCK_STATEMENT"}, {"read", "STATBLOCK_STATEMENT"}, {"while", "STATBLOCK_STATEMENT"}, {"else", "STATBLOCK_EPSILON"}, {"then", "error"}, {"if", "STATBLOCK_STATEMENT"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATBLOCK", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "STATEMENT_id_STATEMENT1_semi"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "STATEMENT_return_lpar_EXPR_rpar_semi"}, {"write", "STATEMENT_write_lpar_EXPR_rpar_semi"}, {"read", "STATEMENT_read_lpar_VARIABLE_rpar_semi"}, {"while", "STATEMENT_while_lpar_RELEXPR_rpar_STATBLOCK_semi"}, {"else", "error"}, {"then", "error"}, {"if", "STATEMENT_if_lpar_RELEXPR_rpar_then_STATBLOCK_else_STATBLOCK_semi"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATEMENT", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "STATEMENT1_VARIABLETAIL_STATEMENT2"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "STATEMENT1_FUNCTIONCALLTAIL_STATEMENT3"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "STATEMENT1_VARIABLETAIL_STATEMENT2"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "STATEMENT1_VARIABLETAIL_STATEMENT2"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATEMENT1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "STATEMENT2_dot_id_STATEMENT1"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "STATEMENT2_ASSIGNOP_EXPR"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATEMENT2", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "STATEMENT3_dot_id_STATEMENT1"}, {"semi", "STATEMENT3_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATEMENT3", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "STRUCTDECL_struct_id_OPTSTRUCTDECL2_lcurbr_REPTSTRUCTDECL4_rcurbr_semi"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STRUCTDECL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "STRUCTORIMPLORFUNC_STRUCTDECL"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "STRUCTORIMPLORFUNC_IMPLDEF"}, {"arrow", "error"}, {"func", "STRUCTORIMPLORFUNC_FUNCDEF"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STRUCTORIMPLORFUNC", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "TERM_FACTOR_RIGHTRECTERM"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "TERM_FACTOR_RIGHTRECTERM"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "TERM_FACTOR_RIGHTRECTERM"}, {"plus", "TERM_FACTOR_RIGHTRECTERM"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "TERM_FACTOR_RIGHTRECTERM"}, {"floatlit", "TERM_FACTOR_RIGHTRECTERM"}, {"intlit", "TERM_FACTOR_RIGHTRECTERM"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("TERM", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "TYPE_id"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "TYPE_float"}, {"integer", "TYPE_integer"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("TYPE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "VARDECL_let_id_colon_TYPE_REPTVARDECL4_semi"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARDECL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "VARDECLORSTAT_STATEMENT"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "VARDECLORSTAT_VARDECL"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "VARDECLORSTAT_STATEMENT"}, {"write", "VARDECLORSTAT_STATEMENT"}, {"read", "VARDECLORSTAT_STATEMENT"}, {"while", "VARDECLORSTAT_STATEMENT"}, {"else", "error"}, {"then", "error"}, {"if", "VARDECLORSTAT_STATEMENT"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARDECLORSTAT", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "VARIABLE_id_VARIABLE1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "VARIABLE1_VARIABLETAIL_VARIABLE2"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "VARIABLE1_VARIABLETAIL_VARIABLE2"}, {"lpar", "VARIABLE1_FUNCTIONCALLTAIL_VARIABLE3"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "VARIABLE1_VARIABLETAIL_VARIABLE2"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "VARIABLE1_VARIABLETAIL_VARIABLE2"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLE1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "VARIABLE2_dot_id_VARIABLE1"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "VARIABLE2_EPSILON"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "VARIABLE2_EPSILON"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLE2", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "VARIABLE3_dot_id_VARIABLE1"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLE3", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "VARIABLETAIL_EPSILON"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "VARIABLETAIL_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "VARIABLETAIL_EPSILON"}, {"plus", "VARIABLETAIL_EPSILON"}, {"void", "error"}, {"comma", "VARIABLETAIL_EPSILON"}, {"geq", "VARIABLETAIL_EPSILON"}, {"leq", "VARIABLETAIL_EPSILON"}, {"gt", "VARIABLETAIL_EPSILON"}, {"lt", "VARIABLETAIL_EPSILON"}, {"neq", "VARIABLETAIL_EPSILON"}, {"eq", "VARIABLETAIL_EPSILON"}, {"inherits", "error"}, {"and", "VARIABLETAIL_EPSILON"}, {"div", "VARIABLETAIL_EPSILON"}, {"mult", "VARIABLETAIL_EPSILON"}, {"rsqbr", "VARIABLETAIL_EPSILON"}, {"lsqbr", "VARIABLETAIL_INDICE_VARIABLETAIL"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "VARIABLETAIL_EPSILON"}, {"intnum", "error"}, {"or", "VARIABLETAIL_EPSILON"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLETAIL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "VISIBILITY_private"}, {"public", "VISIBILITY_public"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatlit", "error"}, {"intlit", "error"}, {"equal", "error"}, {"intnum", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VISIBILITY", table_entry_table);

    }

    /**
     * import rules from final LL1 grammar file
     */
    public void importRules() {
        String file_name = "LL1Attribute.grm";
        System.out.println("[Grammar] Reading the grammar rules from file: " + file_name);

        try {
//            InputStream in = getClass().getResourceAsStream(file_name);
            BufferedReader reader = new BufferedReader(new FileReader(file_name));
            String this_line;
            while ((this_line = reader.readLine()) != null) {
                if (!this_line.isEmpty()) {
                    String[] ruleString = this_line.split("->");
                    Rule rule = new Rule();
                    rule.setRule_LHS(ruleString[0].trim());
                    if (ruleString[1].startsWith("  .")) {
                        ruleString[1] = ruleString[1].replace("  .", "EPSILON").trim();
                        rule.setRule_RHS(ruleString[1]);
                    } else {
                        rule.setRule_RHS(ruleString[1].substring(0, ruleString[1].lastIndexOf(".") - 1));
                    }

                    // match rule ID with the ones in parsing table
                    String ruleId = rule.getRule_LHS() + "_" + rule.getRule_RHS().trim().replaceAll(" ", "_");
                    ruleId = ruleId.replaceAll("_sa-\\d*", "");
                    rule.setRule_id(ruleId);
                    rules_attribute.put(rule.getRule_id(), rule);
                }
            }

            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public ArrayList<String> getTerminal_list() {
        return terminal_list;
    }
    public ArrayList<String> getNonTerminal_list() {
        return nonTerminal_list;
    }
    public Map<String, Map<String, String>> getParsing_table() {
        return parsing_table;
    }
    public Map<String, ArrayList<String>> getFollow_sets() {
        return follow_sets;
    }
    public Map<String, ArrayList<String>> getFirst_sets() {
        return first_sets;
    }
    public Map<String, Rule> getRules_attribute() {
        return rules_attribute;
    }
    public Map<String, String> getSymbol_map() {
        return symbol_map;
    }
}
