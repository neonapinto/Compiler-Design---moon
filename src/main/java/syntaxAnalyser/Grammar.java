package syntaxAnalyser;

import java.io.*;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Grammar {
    private ArrayList<String> terminal_list;
    private ArrayList<String> nonTerminal_list;
    private Map<String, String> symbol_map;
    private final ArrayList<String> semantic_actions_list;
    private final Map<String, Rule> rules_attribute;
    private Map<String, ArrayList<String>> follow_sets;
    private Map<String, ArrayList<String>> first_sets;
    private Map<String, Map<String, String>> parsing_table;
    private Map<String, SemanticAction> semantic_actions;

    public Grammar() {
        nonTerminal_list = new ArrayList<>();
        semantic_actions_list = new ArrayList<>();
        rules_attribute = new HashMap<>();
        follow_sets = new HashMap<>();
        first_sets = new HashMap<>();
        parsing_table = new HashMap<>();
    }

    /**
     * function to map terminals to the symbols, create terminal list and non-terminal list used while parsing
     */
    public void createSymbols() {
        symbol_map = Stream.of(new String[][]{{"dot", "."}, {"semi", ";"}, {"rpar", ")"}, {"lpar", "("},
                {"rcurbr", "}"}, {"lcurbr", "{"}, {"minus", "-"}, {"plus", "+"}, {"geq", ">="},
                {"leq", "<="}, {"gt", ">"}, {"lt", "<"}, {"neq", "<>"}, {"eq", "=="}, {"comma", ","},
                {"div", "/"}, {"mult", "*"}, {"rsqbr", "]"}, {"lsqbr", "["}, {"colon", ":"},
                {"not", "!"}, {"assign", "="}, {"or", "|"},{"and","&"},{"arrow","->"}
        }).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        terminal_list = new ArrayList<>(Arrays.asList("$", "private", "public", "id", "dot", "semi", "struct", "float", "integer",
                "rpar", "lpar", "return", "write", "read", "while", "else", "then", "if", "rcurbr", "let","arrow",
                "lcurbr", "minus", "plus", "geq", "leq", "gt", "lt", "neq", "eq", "comma", "and", "div", "mult",
                "intnum", "inherits", "rsqbr", "lsqbr", "colon", "func", "void", "impl", "not", "floatnum", "assign", "or"));
        nonTerminal_list = new ArrayList<>(Arrays.asList(
                "START", "ADDOP", "APARAMS", "APARAMSTAIL", "ARITHEXPR", "ARRAYSIZE", "ARRAYSIZE1",
                "ASSIGNOP", "ASSIGNSTAT", "CLASSDECL", "EXPR1", "EXPR", "FACTOR1", "FACTOR2",
                "FACTOR", "FPARAMS", "FPARAMSTAIL", "FUNCBODY", "FUNCDECL", "FUNCDEF", "FUNCTIONCALL","FUNCTIONCALL1","FUNCTIONCALL2",
                "FUNCHEAD", "FUNCTIONCALLTAIL","IDNEST","IDNEST1","IMPLDEF", "INDICE",
                "MEMBERDECL", "MULTOP", "OPTSTRUCTDECL2", "PROG", "RELOP", "REPTAPARAMS1", "REPTFPARAMS3","REPTFPARAMS4",
                "SIGN", "RELEXPR","REPTFPARAMSTAIL4","REPTFUNCBODY1","REPTIDNEST1","REPTIMPLDEF3","REPTOPTSTRUCTDECL22",
                "REPTPROG0","REPTSTATBLOCK1","REPTSTRUCTDECL4","REPTVARDECL4","RETURNTYPE","RIGHTRECARITHEXPR","RIGHTRECTERM",
                "STATBLOCK", "STATEMENT", "STATEMENT1", "STATEMENT2","STATEMENT3","STRUCTDECL","STRUCTORIMPLORFUNC",
                "TERM","TYPE", "VARDECL", "VARIABLE2","VARIABLE3","VARDECLORSTAT", "VARIABLE", "VARIABLE1", "VARIABLETAIL", "VISIBILITY"));
    }

    /**
     * creating the symbols, rules, first and follow sets and creating the parsing table.
     */
    public void generateGrammarProject() {
        createSymbols();
        importRules();
        createFirstSets();
        createFollowSets();
        createParsingTable();
        createSemanticActions();
    }

    /**
     * creating first sets used for skiperror()
     */
    private void createFirstSets() {
        first_sets.put("ADDOP", new ArrayList<>(Arrays.asList("plus", "minus", "or")));
        first_sets.put("ARRAYSIZE1", new ArrayList<>(Arrays.asList("intnum", "rsqbr")));
        first_sets.put("ASSIGNSTAT", new ArrayList<>(Collections.singletonList("id")));
        first_sets.put("EXPR1", new ArrayList<>(Arrays.asList("eq", "neq", "lt", "gt", "leq", "geq","EPSILON")));
        first_sets.put("FACTOR2", new ArrayList<>(Arrays.asList("dot", "EPSILON")));
        first_sets.put("FACTOR1",new ArrayList<>(Arrays.asList("dot","lpar","lsqbr", "EPSILON")));
        first_sets.put("FUNCBODY", new ArrayList<>(Collections.singletonList("lcurbr")));
        first_sets.put("FUNCHEAD", new ArrayList<>(Collections.singletonList("func")));
        first_sets.put("FPARAMS", new ArrayList<>(Arrays.asList("id", "EPSILON")));
        follow_sets.put("IDNEST", new ArrayList<>(Collections.singletonList("id")));
        first_sets.put("IDNEST1", new ArrayList<>(Arrays.asList("lpar", "lsqbr","EPSILON")));
        first_sets.put("APARAMS", new ArrayList<>(Arrays.asList("id", "intnum", "floatnum", "lpar", "not", "plus", "minus","EPSILON")));
        first_sets.put("FUNCDECL", new ArrayList<>(Collections.singletonList("func")));
        first_sets.put("ARITHEXPR", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        first_sets.put("RELOP", new ArrayList<>(Arrays.asList("eq", "neq", "lt", "gt", "leq", "geq")));
        first_sets.put("APARAMSTAIL", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTAPARAMS1", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTFPARAMS3", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("FPARAMSTAIL", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTFPARAMS4", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTFPARAMSTAIL4", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("REPTFUNCBODY1", new ArrayList<>(Arrays.asList("let", "id", "if", "while", "read", "write", "return","EPSILON")));
        first_sets.put("REPTIDNEST1", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("REPTOPTSTRUCTDECL22", new ArrayList<>(Arrays.asList("comma", "EPSILON")));
        first_sets.put("REPTIMPLDEF3", new ArrayList<>(Arrays.asList("func", "EPSILON")));
        first_sets.put("REPTPROG0", new ArrayList<>(Arrays.asList("struct", "impl", "func", "EPSILON")));
        first_sets.put("MEMBERDECL", new ArrayList<>(Arrays.asList("func", "let")));
        first_sets.put("ARRAYSIZE", new ArrayList<>(Collections.singletonList("lsqbr")));
        first_sets.put("RETURNTYPE", new ArrayList<>(Arrays.asList("void", "integer", "float", "id")));
        first_sets.put("RIGHTRECARITHEXPR", new ArrayList<>(Arrays.asList("plus", "minus", "or")));
        first_sets.put("SIGN", new ArrayList<>(Arrays.asList("plus", "minus")));
        first_sets.put("MULTOP", new ArrayList<>(Arrays.asList("mult", "div", "and")));
        first_sets.put("PROG", new ArrayList<>(Arrays.asList("struct", "impl", "func", "EPSILON")));
        first_sets.put("START", new ArrayList<>(Arrays.asList("struct", "impl", "func", "EPSILON")));
        first_sets.put("REPTSTATBLOCK1", new ArrayList<>(Arrays.asList("id", "if", "while", "read", "write", "return", "EPSILON")));
        first_sets.put("RELEXPR", new ArrayList<>(Arrays.asList("id", "intnum", "floatnum", "lpar", "not", "plus", "minus")));
        first_sets.put("STATBLOCK", new ArrayList<>(Arrays.asList("lcurbr", "if", "while", "read", "write", "return", 	"id", "EPSILON")));
        first_sets.put("STATEMENT2", new ArrayList<>(Arrays.asList("dot", "assign")));
        first_sets.put("ASSIGNOP", new ArrayList<>(Collections.singletonList("assign")));
        first_sets.put("EXPR", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        first_sets.put("STATEMENT3", new ArrayList<>(Arrays.asList("dot", "EPSILON")));
        first_sets.put("STATEMENT1", new ArrayList<>(Arrays.asList("dot", "lpar", "lsqbr", "assign")));
        first_sets.put("OPTSTRUCTDECL2", new ArrayList<>(Arrays.asList("inherits", "EPSILON")));
        first_sets.put("REPTSTRUCTDECL4", new ArrayList<>(Arrays.asList("public", "private", "EPSILON")));
        first_sets.put("STRUCTORIMPLORFUNC", new ArrayList<>(Arrays.asList("struct", "impl", "func")));
        first_sets.put("STRUCTDECL", new ArrayList<>(Collections.singletonList("struct")));
        first_sets.put("IMPLDEF", new ArrayList<>(Collections.singletonList("impl")));
        first_sets.put("FUNCDEF", new ArrayList<>(Collections.singletonList("func")));
        first_sets.put("TERM", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        first_sets.put("FACTOR", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        first_sets.put("RIGHTRECTERM", new ArrayList<>(Arrays.asList("mult", "div", "and","EPSILON")));
        first_sets.put("TYPE", new ArrayList<>(Arrays.asList("integer", "float", "id")));
        first_sets.put("REPTVARDECL4", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("VARDECLORSTAT", new ArrayList<>(Arrays.asList("let", "id", "if", "while", "read", "write", "return")));
        first_sets.put("VARDECL", new ArrayList<>(Collections.singletonList("let")));
        first_sets.put("STATEMENT", new ArrayList<>(Arrays.asList("if", "while", "read", "write", "return", "id")));
        first_sets.put("VARIABLE", new ArrayList<>(Collections.singletonList("id")));
        first_sets.put("FUNCTIONCALLTAIL", new ArrayList<>(Collections.singletonList("lpar")));
        first_sets.put("VARIABLE2", new ArrayList<>(Arrays.asList("dot", "EPSILON")));
        first_sets.put("VARIABLE3", new ArrayList<>(Collections.singletonList("dot")));
        first_sets.put("VARIABLE1", new ArrayList<>(Arrays.asList("dot","lpar","lsqbr", "EPSILON")));
        first_sets.put("INDICE", new ArrayList<>(Collections.singletonList("lsqbr")));
        first_sets.put("VARIABLETAIL", new ArrayList<>(Arrays.asList("lsqbr", "EPSILON")));
        first_sets.put("VISIBILITY", new ArrayList<>(Arrays.asList("public", "private")));
    }

    /**
     * creating follow sets used for skiperrors()
     */
    private void createFollowSets() {
        follow_sets.put("ADDOP", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("ARRAYSIZE1", new ArrayList<>(Arrays.asList("semi", "lsqbr", "rpar", "comma")));
        follow_sets.put("ASSIGNSTAT", new ArrayList<>(Collections.singletonList("∅")));
        follow_sets.put("EXPR1", new ArrayList<>(Arrays.asList("semi", "comma", "rpar")));
        follow_sets.put("FACTOR2", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma", "rsqbr", "rpar")));
        follow_sets.put("FACTOR1", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma", "rsqbr", "rpar")));
        follow_sets.put("FUNCBODY", new ArrayList<>(Arrays.asList("struct", "impl", "rcurbr", "func")));
        follow_sets.put("FUNCHEAD", new ArrayList<>(Arrays.asList("semi","lcurbr")));
        follow_sets.put("FPARAMS", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("IDNEST", new ArrayList<>(Collections.singletonList("∅")));
        follow_sets.put("IDNEST1", new ArrayList<>(Collections.singletonList("dot")));
        follow_sets.put("APARAMS", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("FUNCDECL", new ArrayList<>(Arrays.asList("public", "private", "rcurbr")));
        follow_sets.put("ARITHEXPR", new ArrayList<>(Arrays.asList("semi", "eq", "neq", "lt", "gt", "leq", "geq", "comma", "rsqbr", "rpar")));
        follow_sets.put("RELOP", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("APARAMSTAIL", new ArrayList<>(Arrays.asList("comma","rpar")));
        follow_sets.put("REPTAPARAMS1", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("REPTFPARAMS3", new ArrayList<>(Arrays.asList("comma","rpar")));
        follow_sets.put("FPARAMSTAIL", new ArrayList<>(Arrays.asList("comma","rpar")));
        follow_sets.put("REPTFPARAMS4", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("REPTFPARAMSTAIL4", new ArrayList<>(Arrays.asList("comma","rpar")));
        follow_sets.put("REPTFUNCBODY1", new ArrayList<>(Collections.singletonList("rcurbr")));
        follow_sets.put("REPTIDNEST1", new ArrayList<>(Collections.singletonList("dot")));
        follow_sets.put("REPTIMPLDEF3", new ArrayList<>(Collections.singletonList("rcurbr")));
        follow_sets.put("REPTOPTSTRUCTDECL22", new ArrayList<>(Collections.singletonList("lcurbr")));
        follow_sets.put("REPTPROG0", new ArrayList<>(Collections.singletonList("∅")));
        follow_sets.put("MEMBERDECL", new ArrayList<>(Arrays.asList("public", "private", "rcurbr")));
        follow_sets.put("ARRAYSIZE", new ArrayList<>(Arrays.asList("rpar", "comma", "semi","lsqbr")));
        follow_sets.put("RETURNTYPE", new ArrayList<>(Arrays.asList("lcurbr", "semi")));
        follow_sets.put("RIGHTRECARITHEXPR", new ArrayList<>(Arrays.asList("semi", "eq", "neq", "lt", "gt", "leq", "geq", "comma", "rsqbr", "rpar")));
        follow_sets.put("MULTOP", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("SIGN", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("START", new ArrayList<>(Collections.singletonList("∅")));
        follow_sets.put("PROG", new ArrayList<>(Collections.singletonList("∅")));
        follow_sets.put("REPTSTATBLOCK1", new ArrayList<>(Collections.singletonList("rcurbr")));
        follow_sets.put("RELEXPR", new ArrayList<>(Collections.singletonList("rpar")));
        follow_sets.put("STATBLOCK", new ArrayList<>(Arrays.asList("else", "semi")));
        follow_sets.put("STATEMENT2", new ArrayList<>(Collections.singletonList("semi")));
        follow_sets.put("ASSIGNOP", new ArrayList<>(Arrays.asList("intnum", "floatnum", "lpar", "not", "id", "plus", "minus")));
        follow_sets.put("EXPR", new ArrayList<>(Arrays.asList("semi", "comma", "rpar")));
        follow_sets.put("STATEMENT3", new ArrayList<>(Collections.singletonList("semi")));
        follow_sets.put("STATEMENT1", new ArrayList<>(Collections.singletonList("semi")));
        follow_sets.put("OPTSTRUCTDECL2", new ArrayList<>(Collections.singletonList("lcurbr")));
        follow_sets.put("REPTSTRUCTDECL4", new ArrayList<>(Collections.singletonList("rcurbr")));
        follow_sets.put("STRUCTORIMPLORFUNC", new ArrayList<>(Arrays.asList("struct", "impl", "func")));
        follow_sets.put("STRUCTDECL", new ArrayList<>(Arrays.asList("struct", "impl", "func")));
        follow_sets.put("IMPLDEF", new ArrayList<>(Arrays.asList("struct", "impl", "func")));
        follow_sets.put("FUNCDEF", new ArrayList<>(Arrays.asList("struct", "impl", "func", "rcurbr")));
        follow_sets.put("TERM", new ArrayList<>(Arrays.asList("semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma", "rsqbr", "rpar")));
        follow_sets.put("FACTOR", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma",  "rsqbr", "rpar")));
        follow_sets.put("RIGHTRECTERM", new ArrayList<>(Arrays.asList("semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma", "rsqbr", "rpar")));
        follow_sets.put("TYPE", new ArrayList<>(Arrays.asList("lcurbr", "semi", "rpar", "comma", "lsqbr")));
        follow_sets.put("REPTVARDECL4", new ArrayList<>(Collections.singletonList("semi")));
        follow_sets.put("VARDECLORSTAT", new ArrayList<>(Arrays.asList("if", "while", "read", "write", "return", "let", "id", "rcurbr")));
        follow_sets.put("VARDECL", new ArrayList<>(Arrays.asList("public", "private", "let", "while", "read", "write", "return", "if", "id", "rcurbr")));
        follow_sets.put("STATEMENT", new ArrayList<>(Arrays.asList("if", "while", "read", "write", "return", "let", "id", "else", "semi", "rcurbr")));
        follow_sets.put("VARIABLE", new ArrayList<>(Arrays.asList("assign", "rpar")));
        follow_sets.put("FUNCTIONCALLTAIL", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma",  "rsqbr", "rpar","dot")));
        follow_sets.put("VARIABLE2", new ArrayList<>(Arrays.asList("assign", "rpar")));
        follow_sets.put("VARIABLE3", new ArrayList<>(Arrays.asList("assign", "rpar")));
        follow_sets.put("VARIABLE1", new ArrayList<>(Arrays.asList("assign", "rpar")));
        follow_sets.put("INDICE", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma",  "rsqbr", "rpar","dot","lsqbr","assign")));
        follow_sets.put("VARIABLETAIL", new ArrayList<>(Arrays.asList("mult", "div", "and", "semi", "eq", "neq", "lt", "gt", "leq", "geq", "plus", "minus", "or", "comma",  "rsqbr", "rpar", "dot", "assign")));
        follow_sets.put("VISIBILITY", new ArrayList<>(Arrays.asList("func", "let")));
    }

    private void createSemanticActions() {
        semantic_actions = new HashMap<>();
        semantic_actions.put("sa-03", new SemanticAction("sa-03", "Prog_s", "makeFamily(Prog, StructDecl_s, FuncDef_s, ImplDef_s, n)"));
        semantic_actions.put("sa-01", new SemanticAction("sa-01", "StructList_s", "makeFamily(StructList, StructDecl_s, n)"));
        semantic_actions.put("sa-02", new SemanticAction("sa-02", "ImplDefList_s", "makeFamily(ImplDefList, ImplDef_s, n)"));
        semantic_actions.put("sa-27", new SemanticAction("sa-27", "ImplDef_s", "makeFamily(ImplDef, Id_i, FuncDefList_s, n)"));
        semantic_actions.put("sa-09", new SemanticAction("sa-09", "Id_i", "makeNode(Id)"));
        semantic_actions.put("sa-06", new SemanticAction("sa-06", "Id_s", "makeNode(Id)"));
        semantic_actions.put("sa-04", new SemanticAction("sa-04", "StructDecl_s", "makeFamily(StructDecl, Id_i, InheritList_s, MembList_s, n)"));
        semantic_actions.put("sa-07", new SemanticAction("sa-07", "InheritList_s", "makeFamily(InheritList, Id_s, n)"));
        semantic_actions.put("sa-08", new SemanticAction("sa-08", "MembList_s", "makeFamily(MembList, MembDecl_s, n)"));
        semantic_actions.put("sa-57", new SemanticAction("sa-57", "InheritList_s", "makeNode(InheritList)"));
        semantic_actions.put("sa-54", new SemanticAction("sa-54", "MembDecl_s", "makeFamily(MembDecl, Visibility_s, VarDecl_s, FuncDecl_s, 2, any)"));
        semantic_actions.put("sa-55", new SemanticAction("sa-55", "Visibility_s", "makeNode(Visibility)"));
        semantic_actions.put("sa-11", new SemanticAction("sa-11", "VarDecl_s", "makeFamily(VarDecl, Id_s, Type_s, DimList_s)"));
        semantic_actions.put("sa-13", new SemanticAction("sa-13", "Type_s", "makeNode(Type)"));
        semantic_actions.put("sa-53", new SemanticAction("sa-53", "Type_s", "makeFamily(Type, Id_s)"));
        semantic_actions.put("sa-14", new SemanticAction("sa-14", "DimList_s", "makeFamily(DimList, Dim_s, n)"));
        semantic_actions.put("sa-15", new SemanticAction("sa-15", "Dim_s", "makeNode(Dim)"));
        semantic_actions.put("sa-58", new SemanticAction("sa-58", "Dim_s", "makeNode(DimNull)"));
        semantic_actions.put("sa-10", new SemanticAction("sa-10", "FuncDecl_s", "makeFamily(FuncDecl, Id_s, FParamList_s, Type_s)"));
        semantic_actions.put("sa-12", new SemanticAction("sa-12", "FParamList_s", "makeFamily(FParamList, FParam_s, n)"));
        semantic_actions.put("sa-16", new SemanticAction("sa-16", "FParam_s", "makeFamily(FParam, Id_s,  Type_s, DimList_s)"));

        semantic_actions.put("sa-05", new SemanticAction("sa-05", "FuncDefList_s", "makeFamily(FuncDefList, FuncDef_s, n)"));
        semantic_actions.put("sa-17", new SemanticAction("sa-17", "FuncDef_s", "makeFamily(FuncDef, Id_s, FParamList_s, Type_s, FuncBody_s)"));
        semantic_actions.put("sa-18", new SemanticAction("sa-18", "FuncBody_s", "makeFamily(FuncBody, VarDecl_s, StatBlock_s, n)"));
        semantic_actions.put("sa-30", new SemanticAction("sa-30", "Expr_s", "makeFamily(Expr, ArithExpr_s, RelExpr_s, any)"));
        semantic_actions.put("sa-33", new SemanticAction("sa-33", "ArithExpr_s", "makeFamily(ArithExpr, Term_s, AddOp_s, any)"));
        semantic_actions.put("sa-35", new SemanticAction("sa-35", "Term_s", "makeFamily(Term, Factor_s, MultOp_s, any)"));
        semantic_actions.put("sa-36", new SemanticAction("sa-36", "Factor_s", "makeFamily(Factor, Num_s, Float_s, FuncOrVar_s, Expr_s, Not_s, Sign_s, any)"));
        semantic_actions.put("sa-44", new SemanticAction("sa-44", "FuncOrVar_s", "makeFamily(FuncOrVar, DataMem_s, Dot_s, FuncCall_s, any)"));
        semantic_actions.put("sa-52", new SemanticAction("sa-52", "DataMem_s", "makeFamily(DataMem, Id_s, Indice_s)"));
        semantic_actions.put("sa-51", new SemanticAction("sa-51", "Indice_s", "makeFamily(Indice, Expr_s, n)"));
        semantic_actions.put("sa-63", new SemanticAction("sa-63", "Dot_s", "makeFamily(Dot, DataMem_s, Dot_s, DataMem_s, keepOrSkip, first2, any)"));   // maybe a dot or just a dataMem special case
        semantic_actions.put("sa-65", new SemanticAction("sa-65", "Dot_s", "makeFamily(Dot, FuncCall_s, DataMem_s, keepOrSkip)"));
        semantic_actions.put("sa-62", new SemanticAction("sa-62", "Dot_s", "makeFamily(Dot, DataMem_s, Id_s, keepOrSkip)"));    // if not DataMem, skip; if DataMem, combine
        semantic_actions.put("sa-29", new SemanticAction("sa-29", "Null_s", "makeNode(Null)"));   // as a EPSILON
        semantic_actions.put("sa-49", new SemanticAction("sa-49", "FuncCall_s", "makeFamily(FuncCall, Id_s, Dot_s, AParams_s, first2, any)"));
        semantic_actions.put("sa-64", new SemanticAction("sa-64", "FuncCall_s", "makeFamily(FuncCall, Dot_s, DataMem_s, FuncCall_s, keepOrSkip, first2, any)"));    // if not DataMem, just skip; if DataMem, combine
        semantic_actions.put("sa-60", new SemanticAction("sa-60", "FuncCallStat_s", "makeFamily(FuncCallStat, FuncCall_s, n)"));
        semantic_actions.put("sa-50", new SemanticAction("sa-50", "AParams_s", "makeFamily(AParams, Null_s, Expr_s, n)"));
        semantic_actions.put("sa-39", new SemanticAction("sa-39", "Num_s", "makeNode(Num)"));
        semantic_actions.put("sa-66", new SemanticAction("sa-66", "Float_s", "makeNode(Float)"));
        semantic_actions.put("sa-41", new SemanticAction("sa-41", "Not_s", "makeFamily(Not, Factor_s)"));
        semantic_actions.put("sa-42", new SemanticAction("sa-42", "Sign_s", "makeFamily(Sign_i, Factor_s, reuse)"));
        semantic_actions.put("sa-46", new SemanticAction("sa-46", "Sign_i", "makeNode(Sign)"));
        semantic_actions.put("sa-38", new SemanticAction("sa-38", "MultOp_s", "makeFamily(MultOp_i, Term_s, MultOp_i, Factor_s, reuse)"));
        semantic_actions.put("sa-48", new SemanticAction("sa-48", "MultOp_i", "makeNode(MultOp)"));
        semantic_actions.put("sa-37", new SemanticAction("sa-37", "AddOp_s", "makeFamily(AddOp_i, ArithExpr_s, AddOp_i, Term_s, reuse)"));
        semantic_actions.put("sa-47", new SemanticAction("sa-47", "AddOp_i", "makeNode(AddOp)"));
        semantic_actions.put("sa-34", new SemanticAction("sa-34", "RelExpr_s", "makeFamily(RelExpr, Expr_s, RelOp_s, Expr_s)"));
        semantic_actions.put("sa-45", new SemanticAction("sa-45", "RelOp_s", "makeNode(RelOp)"));
        semantic_actions.put("sa-21", new SemanticAction("sa-21", "StatBlock_s", "makeFamily(StatBlock, VarDecl_s, IfStat_s, WhileStat_s, ReadStat_s, WriteStat_s, ReturnStat_s, FuncCallStat_s, AssignStat_s, n)"));
        semantic_actions.put("sa-22", new SemanticAction("sa-22", "IfStat_s", "makeFamily(IfStat, Expr_s, StatBlock_s, StatBlock_s)"));
        semantic_actions.put("sa-23", new SemanticAction("sa-23", "WhileStat_s", "makeFamily(WhileStat, Expr_s, StatBlock_s)"));
        semantic_actions.put("sa-24", new SemanticAction("sa-24", "ReadStat_s", "makeFamily(ReadStat, Variable_s)"));
        semantic_actions.put("sa-31", new SemanticAction("sa-31", "Variable_s", "makeFamily(Variable, DataMem_s, Dot_s, any)"));
        semantic_actions.put("sa-61", new SemanticAction("sa-61", "Dot_s", "makeFamily(Dot, DataMem_s, Dot_s, DataMem_s, 2, any)"));
        semantic_actions.put("sa-25", new SemanticAction("sa-25", "WriteStat_s", "makeFamily(WriteStat, Expr_s)"));
        semantic_actions.put("sa-26", new SemanticAction("sa-26", "ReturnStat_s", "makeFamily(ReturnStat, Expr_s)"));
        semantic_actions.put("sa-32", new SemanticAction("sa-32", "AssignStat_s", "makeFamily(AssignStat, Variable_s, Expr_s)"));


        // initialize semantic actions list
        for (Map.Entry<String, SemanticAction> pair : semantic_actions.entrySet()) {
            semantic_actions_list.add(pair.getKey());
        }

    }

    /**
     * Creating the parsing table using the first and follow sets
     */
    private void createParsingTable() {
        Map<String, String> table_entry_table;
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "ADDOP_minus"}, {"plus", "ADDOP_plus"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"}, {"or", "ADDOP_or"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ADDOP", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "APARAMS_EXPR_REPTAPARAMS1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "APARAMS_EPSILON"}, {"lpar", "APARAMS_EXPR_REPTAPARAMS1"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "APARAMS_EXPR_REPTAPARAMS1"}, {"plus", "APARAMS_EXPR_REPTAPARAMS1"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "APARAMS_EXPR_REPTAPARAMS1"}, {"floatnum", "APARAMS_EXPR_REPTAPARAMS1"}, {"intnum", "APARAMS_EXPR_REPTAPARAMS1"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("APARAMS", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "APARAMSTAIL_comma_EXPR"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("APARAMSTAIL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"plus", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"floatnum", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"intnum", "ARITHEXPR_TERM_RIGHTRECARITHEXPR"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ARITHEXPR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "ARRAYSIZE_lsqbr_ARRAYSIZE1"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ARRAYSIZE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "ARRAYSIZE1_rsqbr"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "ARRAYSIZE1_intnum_rsqbr"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ARRAYSIZE1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "ASSIGNOP_assign"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ASSIGNOP", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "ASSIGNSTAT_VARIABLE_ASSIGNOP_EXPR"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("ASSIGNSTAT", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "EXPR_ARITHEXPR_EXPR1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "EXPR_ARITHEXPR_EXPR1"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "EXPR_ARITHEXPR_EXPR1"}, {"plus", "EXPR_ARITHEXPR_EXPR1"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "EXPR_ARITHEXPR_EXPR1"}, {"floatnum", "EXPR_ARITHEXPR_EXPR1"}, {"intnum", "EXPR_ARITHEXPR_EXPR1"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("EXPR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "EXPR1_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "EXPR1_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "EXPR1_EPSILON"}, {"geq", "EXPR1_RELOP_ARITHEXPR"}, {"leq", "EXPR1_RELOP_ARITHEXPR"}, {"gt", "EXPR1_RELOP_ARITHEXPR"}, {"lt", "EXPR1_RELOP_ARITHEXPR"}, {"neq", "EXPR1_RELOP_ARITHEXPR"}, {"eq", "EXPR1_RELOP_ARITHEXPR"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("EXPR1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "FACTOR_id_FACTOR1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "FACTOR_lpar_ARITHEXPR_rpar"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "FACTOR_SIGN_FACTOR"}, {"plus", "FACTOR_SIGN_FACTOR"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "FACTOR_not_FACTOR"}, {"floatnum", "FACTOR_floatnum"}, {"intnum", "FACTOR_intnum"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FACTOR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"semi", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"lpar", "FACTOR1_FUNCTIONCALLTAIL_FACTOR2"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"plus", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"void", "error"}, {"comma", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"geq", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"leq", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"gt", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"lt", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"neq", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"eq", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"inherits", "error"}, {"and", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"div", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"mult", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"rsqbr", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"lsqbr", "FACTOR1_VARIABLETAIL_FACTOR2"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"}, {"or", "FACTOR1_VARIABLETAIL_FACTOR2"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FACTOR1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "FACTOR2_dot_id_FACTOR1"}, {"semi", "FACTOR2_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "FACTOR2_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "FACTOR2_EPSILON"}, {"plus", "FACTOR2_EPSILON"}, {"void", "error"}, {"comma", "FACTOR2_EPSILON"}, {"geq", "FACTOR2_EPSILON"}, {"leq", "FACTOR2_EPSILON"}, {"gt", "FACTOR2_EPSILON"}, {"lt", "FACTOR2_EPSILON"}, {"neq", "FACTOR2_EPSILON"}, {"eq", "FACTOR2_EPSILON"}, {"inherits", "error"}, {"and", "FACTOR2_EPSILON"}, {"div", "FACTOR2_EPSILON"}, {"mult", "FACTOR2_EPSILON"}, {"rsqbr", "FACTOR2_EPSILON"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "FACTOR2_EPSILON"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FACTOR2", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "FPARAMS_id_colon_TYPE_REPTFPARAMS3_REPTFPARAMS4"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "FPARAMS_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FPARAMS", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "FPARAMSTAIL_comma_id_colon_TYPE_REPTFPARAMSTAIL4"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FPARAMSTAIL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "FUNCBODY_lcurbr_REPTFUNCBODY1_rcurbr"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCBODY", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "FUNCDECL_FUNCHEAD_semi"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCDECL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "FUNCDEF_FUNCHEAD_FUNCBODY"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCDEF", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "FUNCHEAD_func_id_lpar_FPARAMS_rpar_arrow_RETURNTYPE"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCHEAD", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "FUNCTIONCALLTAIL_lpar_APARAMS_rpar"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("FUNCTIONCALLTAIL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "IDNEST_id_IDNEST1_dot"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("IDNEST", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "IDNEST1_REPTIDNEST1"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "IDNEST1_lpar_APARAMS_rpar"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "IDNEST1_REPTIDNEST1"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("IDNEST1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "IMPLDEF_impl_id_lcurbr_REPTIMPLDEF3_rcurbr"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("IMPLDEF", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "INDICE_lsqbr_ARITHEXPR_rsqbr"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("INDICE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "MEMBERDECL_VARDECL"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "MEMBERDECL_FUNCDECL"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("MEMBERDECL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "MULTOP_and"}, {"div", "MULTOP_div"}, {"mult", "MULTOP_mult"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("MULTOP", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "OPTSTRUCTDECL2_EPSILON"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "OPTSTRUCTDECL2_inherits_id_REPTOPTSTRUCTDECL22"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("OPTSTRUCTDECL2", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "PROG_REPTPROG0"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "PROG_REPTPROG0"}, {"arrow", "error"}, {"func", "PROG_REPTPROG0"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("PROG", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"plus", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"floatnum", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"intnum", "RELEXPR_ARITHEXPR_RELOP_ARITHEXPR"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RELEXPR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "RELOP_geq"}, {"leq", "RELOP_leq"}, {"gt", "RELOP_gt"}, {"lt", "RELOP_lt"}, {"neq", "RELOP_neq"}, {"eq", "RELOP_eq"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RELOP", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "REPTAPARAMS1_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTAPARAMS1_APARAMSTAIL_REPTAPARAMS1"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTAPARAMS1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "REPTFPARAMS3_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTFPARAMS3_EPSILON"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "REPTFPARAMS3_ARRAYSIZE_REPTFPARAMS3"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTFPARAMS3", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "REPTFPARAMS4_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTFPARAMS4_FPARAMSTAIL_REPTFPARAMS4"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTFPARAMS4", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "REPTFPARAMSTAIL4_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTFPARAMSTAIL4_EPSILON"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "REPTFPARAMSTAIL4_ARRAYSIZE_REPTFPARAMSTAIL4"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTFPARAMSTAIL4", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "REPTFUNCBODY1_EPSILON"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"write", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"read", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"while", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"else", "error"}, {"then", "error"}, {"if", "REPTFUNCBODY1_VARDECLORSTAT_REPTFUNCBODY1"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTFUNCBODY1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "REPTIDNEST1_EPSILON"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "REPTIDNEST1_INDICE_REPTIDNEST1"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTIDNEST1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "REPTIMPLDEF3_EPSILON"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "REPTIMPLDEF3_FUNCDEF_REPTIMPLDEF3"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTIMPLDEF3", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "REPTOPTSTRUCTDECL22_EPSILON"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "REPTOPTSTRUCTDECL22_comma_id_REPTOPTSTRUCTDECL22"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTOPTSTRUCTDECL22", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "REPTPROG0_EPSILON"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "REPTPROG0_STRUCTORIMPLORFUNC_REPTPROG0"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "REPTPROG0_STRUCTORIMPLORFUNC_REPTPROG0"}, {"arrow", "error"}, {"func", "REPTPROG0_STRUCTORIMPLORFUNC_REPTPROG0"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTPROG0", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "REPTSTATBLOCK1_EPSILON"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"write", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"read", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"while", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"else", "error"}, {"then", "error"}, {"if", "REPTSTATBLOCK1_STATEMENT_REPTSTATBLOCK1"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTSTATBLOCK1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "REPTSTRUCTDECL4_VISIBILITY_MEMBERDECL_REPTSTRUCTDECL4"}, {"public", "REPTSTRUCTDECL4_VISIBILITY_MEMBERDECL_REPTSTRUCTDECL4"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "REPTSTRUCTDECL4_EPSILON"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTSTRUCTDECL4", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "REPTVARDECL4_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "REPTVARDECL4_ARRAYSIZE_REPTVARDECL4"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("REPTVARDECL4", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "RETURNTYPE_TYPE"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "RETURNTYPE_TYPE"}, {"integer", "RETURNTYPE_TYPE"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "RETURNTYPE_void"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RETURNTYPE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "RIGHTRECARITHEXPR_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "RIGHTRECARITHEXPR_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "RIGHTRECARITHEXPR_ADDOP_TERM_RIGHTRECARITHEXPR"}, {"plus", "RIGHTRECARITHEXPR_ADDOP_TERM_RIGHTRECARITHEXPR"}, {"void", "error"}, {"comma", "RIGHTRECARITHEXPR_EPSILON"}, {"geq", "RIGHTRECARITHEXPR_EPSILON"}, {"leq", "RIGHTRECARITHEXPR_EPSILON"}, {"gt", "RIGHTRECARITHEXPR_EPSILON"}, {"lt", "RIGHTRECARITHEXPR_EPSILON"}, {"neq", "RIGHTRECARITHEXPR_EPSILON"}, {"eq", "RIGHTRECARITHEXPR_EPSILON"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "RIGHTRECARITHEXPR_EPSILON"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "RIGHTRECARITHEXPR_ADDOP_TERM_RIGHTRECARITHEXPR"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RIGHTRECARITHEXPR", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "RIGHTRECTERM_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "RIGHTRECTERM_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "RIGHTRECTERM_EPSILON"}, {"plus", "RIGHTRECTERM_EPSILON"}, {"void", "error"}, {"comma", "RIGHTRECTERM_EPSILON"}, {"geq", "RIGHTRECTERM_EPSILON"}, {"leq", "RIGHTRECTERM_EPSILON"}, {"gt", "RIGHTRECTERM_EPSILON"}, {"lt", "RIGHTRECTERM_EPSILON"}, {"neq", "RIGHTRECTERM_EPSILON"}, {"eq", "RIGHTRECTERM_EPSILON"}, {"inherits", "error"}, {"and", "RIGHTRECTERM_MULTOP_FACTOR_RIGHTRECTERM"}, {"div", "RIGHTRECTERM_MULTOP_FACTOR_RIGHTRECTERM"}, {"mult", "RIGHTRECTERM_MULTOP_FACTOR_RIGHTRECTERM"}, {"rsqbr", "RIGHTRECTERM_EPSILON"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "RIGHTRECTERM_EPSILON"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("RIGHTRECTERM", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "SIGN_minus"}, {"plus", "SIGN_plus"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("SIGN", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "START_PROG"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "START_PROG"}, {"arrow", "error"}, {"func", "START_PROG"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("START", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "STATBLOCK_STATEMENT"}, {"dot", "error"}, {"semi", "STATBLOCK_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "STATBLOCK_lcurbr_REPTSTATBLOCK1_rcurbr"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "STATBLOCK_STATEMENT"}, {"write", "STATBLOCK_STATEMENT"}, {"read", "STATBLOCK_STATEMENT"}, {"while", "STATBLOCK_STATEMENT"}, {"else", "STATBLOCK_EPSILON"}, {"then", "error"}, {"if", "STATBLOCK_STATEMENT"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATBLOCK", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "STATEMENT_id_STATEMENT1_semi"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "STATEMENT_return_lpar_EXPR_rpar_semi"}, {"write", "STATEMENT_write_lpar_EXPR_rpar_semi"}, {"read", "STATEMENT_read_lpar_VARIABLE_rpar_semi"}, {"while", "STATEMENT_while_lpar_EXPR_rpar_STATBLOCK_semi"}, {"else", "error"}, {"then", "error"}, {"if", "STATEMENT_if_lpar_EXPR_rpar_then_STATBLOCK_else_STATBLOCK_semi"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATEMENT", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "STATEMENT1_VARIABLETAIL_STATEMENT2"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "STATEMENT1_FUNCTIONCALLTAIL_STATEMENT3"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "STATEMENT1_VARIABLETAIL_STATEMENT2"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "STATEMENT1_VARIABLETAIL_STATEMENT2"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATEMENT1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "STATEMENT2_dot_id_STATEMENT1"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "STATEMENT2_ASSIGNOP_EXPR"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATEMENT2", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "STATEMENT3_dot_id_STATEMENT1"}, {"semi", "STATEMENT3_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STATEMENT3", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "STRUCTDECL_struct_id_OPTSTRUCTDECL2_lcurbr_REPTSTRUCTDECL4_rcurbr_semi"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STRUCTDECL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "STRUCTORIMPLORFUNC_STRUCTDECL"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "STRUCTORIMPLORFUNC_IMPLDEF"}, {"arrow", "error"}, {"func", "STRUCTORIMPLORFUNC_FUNCDEF"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("STRUCTORIMPLORFUNC", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "TERM_FACTOR_RIGHTRECTERM"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "TERM_FACTOR_RIGHTRECTERM"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "TERM_FACTOR_RIGHTRECTERM"}, {"plus", "TERM_FACTOR_RIGHTRECTERM"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "TERM_FACTOR_RIGHTRECTERM"}, {"floatnum", "TERM_FACTOR_RIGHTRECTERM"}, {"intnum", "TERM_FACTOR_RIGHTRECTERM"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("TERM", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "TYPE_id"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "TYPE_float"}, {"integer", "TYPE_integer"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("TYPE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "VARDECL_let_id_colon_TYPE_REPTVARDECL4_semi"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARDECL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "VARDECLORSTAT_STATEMENT"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "VARDECLORSTAT_VARDECL"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "VARDECLORSTAT_STATEMENT"}, {"write", "VARDECLORSTAT_STATEMENT"}, {"read", "VARDECLORSTAT_STATEMENT"}, {"while", "VARDECLORSTAT_STATEMENT"}, {"else", "error"}, {"then", "error"}, {"if", "VARDECLORSTAT_STATEMENT"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARDECLORSTAT", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "VARIABLE_id_VARIABLE1"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLE", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "VARIABLE1_VARIABLETAIL_VARIABLE2"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "VARIABLE1_VARIABLETAIL_VARIABLE2"}, {"lpar", "VARIABLE1_FUNCTIONCALLTAIL_VARIABLE3"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "VARIABLE1_VARIABLETAIL_VARIABLE2"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "VARIABLE1_VARIABLETAIL_VARIABLE2"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLE1", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "VARIABLE2_dot_id_VARIABLE1"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "VARIABLE2_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "VARIABLE2_EPSILON"}, {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLE2", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "VARIABLE3_dot_id_VARIABLE1"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLE3", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "error"}, {"public", "error"}, {"id", "error"}, {"dot", "VARIABLETAIL_EPSILON"}, {"semi", "VARIABLETAIL_EPSILON"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "VARIABLETAIL_EPSILON"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "VARIABLETAIL_EPSILON"}, {"plus", "VARIABLETAIL_EPSILON"}, {"void", "error"}, {"comma", "VARIABLETAIL_EPSILON"}, {"geq", "VARIABLETAIL_EPSILON"}, {"leq", "VARIABLETAIL_EPSILON"}, {"gt", "VARIABLETAIL_EPSILON"}, {"lt", "VARIABLETAIL_EPSILON"}, {"neq", "VARIABLETAIL_EPSILON"}, {"eq", "VARIABLETAIL_EPSILON"}, {"inherits", "error"}, {"and", "VARIABLETAIL_EPSILON"}, {"div", "VARIABLETAIL_EPSILON"}, {"mult", "VARIABLETAIL_EPSILON"}, {"rsqbr", "VARIABLETAIL_EPSILON"}, {"lsqbr", "VARIABLETAIL_INDICE_VARIABLETAIL"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "VARIABLETAIL_EPSILON"},  {"or", "VARIABLETAIL_EPSILON"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VARIABLETAIL", table_entry_table);
        table_entry_table = Stream.of(new String[][]{{"$", "error"}, {"private", "VISIBILITY_private"}, {"public", "VISIBILITY_public"}, {"id", "error"}, {"dot", "error"}, {"semi", "error"}, {"colon", "error"}, {"let", "error"}, {"float", "error"}, {"integer", "error"}, {"rcurbr", "error"}, {"lcurbr", "error"}, {"struct", "error"}, {"rpar", "error"}, {"lpar", "error"}, {"return", "error"}, {"write", "error"}, {"read", "error"}, {"while", "error"}, {"else", "error"}, {"then", "error"}, {"if", "error"}, {"minus", "error"}, {"plus", "error"}, {"void", "error"}, {"comma", "error"}, {"geq", "error"}, {"leq", "error"}, {"gt", "error"}, {"lt", "error"}, {"neq", "error"}, {"eq", "error"}, {"inherits", "error"}, {"and", "error"}, {"div", "error"}, {"mult", "error"}, {"rsqbr", "error"}, {"lsqbr", "error"}, {"impl", "error"}, {"arrow", "error"}, {"func", "error"}, {"not", "error"}, {"floatnum", "error"}, {"intnum", "error"}, {"assign", "error"},  {"or", "error"}}).collect(Collectors.toMap(data -> data[0], data -> data[1]));
        parsing_table.put("VISIBILITY", table_entry_table);
    }

    /**
     * import rules from final LL1 grammar file
     */
    public void importRules() {
        String file_name = "LL1_sa.grm";
        System.out.println("[Grammar] Reading the grammar rules from file: " + file_name);
        try {
            BufferedReader reader = new BufferedReader(new FileReader(file_name));
            String this_line;
            while ((this_line = reader.readLine()) != null) {
                if (!this_line.isEmpty()) {
                    String[] ruleString = this_line.split("->");
                    Rule rule = new Rule();
                    rule.setRule_LHS(ruleString[0].trim());
                    if (ruleString[1].startsWith("  .")) {
                        ruleString[1] = ruleString[1].replace("  .", "EPSILON").trim();
                        rule.setRule_RHS(ruleString[1]);
                    } else {
                        rule.setRule_RHS(ruleString[1].substring(0, ruleString[1].lastIndexOf(".") - 1));
                    }
                    // creating ID which is used to match the parsing table
                    String ruleId = rule.getRule_LHS() + "_" + rule.getRule_RHS().trim().replaceAll(" ", "_");
                    ruleId = ruleId.replaceAll("_sa-\\d*", "");
                    rule.setRule_id(ruleId);
                    rules_attribute.put(rule.getRule_id(), rule);
                }
            }
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public ArrayList<String> getTerminal_list() {
        return terminal_list;
    }
    public ArrayList<String> getNonTerminal_list() {
        return nonTerminal_list;
    }
    public Map<String, Map<String, String>> getParsing_table() {
        return parsing_table;
    }
    public Map<String, ArrayList<String>> getFollow_sets() {
        return follow_sets;
    }
    public Map<String, ArrayList<String>> getFirst_sets() {
        return first_sets;
    }
    public Map<String, Rule> getRules_attribute() {
        return rules_attribute;
    }
    public Map<String, String> getSymbol_map() {
        return symbol_map;
    }
    public ArrayList<String> getSemantic_actions_list() {
        return semantic_actions_list;
    }
    public Map<String, SemanticAction> getSemantic_actions() {
        return semantic_actions;
    }
}
